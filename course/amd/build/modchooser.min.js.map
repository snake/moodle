{"version":3,"sources":["../src/modchooser.js"],"names":["init","courseid","fetchModules","webserviceData","allSections","fetchSections","sectionIds","fetchSectionIds","builtModuleData","sectionIdMapper","modalMapper","modalMap","registerEventHandlers","enableInteraction","Promise","all","Repository","activityModules","data","sections","document","querySelectorAll","selectors","elements","section","siteTopic","sitetopic","siteMenu","sitemenu","Array","from","map","button","querySelector","sectionmodchooser","dataset","sectionid","e","webServiceData","builtDataMap","Map","forEach","id","newData","JSON","parse","stringify","allmodules","module","urls","addoption","set","iter","entries","result","next","done","sectionId","value","modules","templateData","templateDataBuilder","buildModal","modal","default","ModalFactory","create","type","types","DEFAULT","title","body","Templates","render","large","templateContext","classes","modulesMap","events","CustomEvents","activate","keyboardActivate","define","event","addEventListener","target","closest","caller","get","ChooserDialogue","displayChooser","disabled"],"mappings":"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","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * A type of dialogue used as for choosing modules in a course.\n *\n * @module     core_course/modchooser\n * @package    core_course\n * @copyright  2020 Mathew May <mathew.solutions>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport * as ChooserDialogue from 'core_course/chooser_dialogue';\nimport CustomEvents from 'core/custom_interaction_events';\nimport * as Repository from 'core_course/local/chooser/repository';\nimport selectors from 'core_course/local/chooser/selectors';\nimport * as Templates from 'core/templates';\nimport * as ModalFactory from 'core/modal_factory';\nimport {get_string as getString} from 'core/str';\n\n/**\n * Set up the activity chooser.\n *\n * @method init\n * @param {int} courseid Course ID to use later on in fetchModules()\n */\nexport const init = async(courseid) => {\n\n    // Fetch all the modules available for a given course.\n    const webserviceData = await fetchModules(courseid);\n\n    const allSections = fetchSections();\n\n    const sectionIds = fetchSectionIds(allSections);\n\n    const builtModuleData = sectionIdMapper(webserviceData, sectionIds);\n\n    const modalMap = await modalMapper(builtModuleData);\n\n    // User interaction handlers.\n    registerEventHandlers(modalMap, builtModuleData);\n\n    enableInteraction(allSections);\n};\n\n/**\n * Call the activity webservice so we get an array of modules\n *\n * @method fetchModules\n * @param {int} courseid Course ID for the course we want modules for\n * @return {Object} The result of the Web service\n */\nconst fetchModules = async(courseid) => {\n    const [\n        data\n    ] = await Promise.all([\n        Repository.activityModules(courseid)\n    ]);\n    return data;\n};\n\n/**\n * Find all the sections on a page\n *\n * @method fetchModules\n * @return {Array} The result of querySelectors that have been spread into a array\n */\nconst fetchSections = () => {\n    const sections = document.querySelectorAll(`${selectors.elements.section}[role=\"region\"]`);\n    const siteTopic = document.querySelectorAll(selectors.elements.sitetopic);\n    const siteMenu = document.querySelectorAll(selectors.elements.sitemenu);\n\n    return [...sections, ...siteTopic, ...siteMenu];\n};\n\n/**\n * Given a NodeList of HTMLElement nodes find their ID's\n *\n * @method fetchSectionIds\n * @param {Array} sections The sections to fetch ID's for\n * @return {Array} Array of section ID's we'll use for maps\n */\nconst fetchSectionIds = (sections) => {\n    const sectionIds = Array.from(sections).map((section) => {\n        const button = section.querySelector(`${selectors.elements.sectionmodchooser}`);\n        try {\n            return button.dataset.sectionid;\n        } catch (e) {\n            // eslint-disable-line\n        }\n    });\n    return sectionIds;\n};\n\n/**\n * Given the web service data and an array of section ID's we want to make deep copies\n * of the WS data then add on the section ID to the addoption URL\n *\n * @method sectionIdMapper\n * @param {Object} webServiceData Our original data from the Web service call\n * @param {Array} sectionIds All of the sections we need to build modal data for\n * @return {Map} A map of K: sectionID V: [modules] with URL's built\n */\nconst sectionIdMapper = (webServiceData, sectionIds) => {\n    const builtDataMap = new Map();\n    sectionIds.forEach((id) => {\n        // We need to take a fresh deep copy of the original data as an object is a reference type.\n        let newData = JSON.parse(JSON.stringify(webServiceData));\n        newData.allmodules.forEach((module) => {\n            module.urls.addoption += '&section=' + id;\n        });\n        builtDataMap.set(id, newData.allmodules);\n    });\n    return builtDataMap;\n};\n\n/**\n * Build a modal for each section ID and store it into a map for quick access\n *\n * @method modalMapper\n * @param {Map} builtModuleData our map of section ID's & modules to generate modals for\n * @return {Map} A map of K: sectionID V: {Modal} with the modal being prebuilt\n */\nconst modalMapper = async(builtModuleData) => {\n    const modalMap = new Map();\n    const iter = builtModuleData.entries();\n    // We need to use a iterator structure as it is a blocking structure.\n    let result = iter.next();\n    while (!result.done) {\n        let sectionId = result.value[0];\n        let modules = result.value[1];\n\n        // Run a call off to a new func for filtering favs & recommended.\n        const templateData = templateDataBuilder(modules);\n        // This may be stuck here :/\n        const modal = await buildModal(templateData);\n        modalMap.set(sectionId, modal);\n\n        result = iter.next();\n    }\n\n    return modalMap;\n};\n\n/**\n * Given an array of modules we want to figure out where & how to place them into our template object\n *\n * @method templateDataBuilder\n * @param {Array} data our modules to manipulate into a Templatable object\n * @return {Object} Our built object ready to render out\n */\nconst templateDataBuilder = (data) => {\n    // const recommended = data.filter(mod => mod.recommended === true);\n    // const favourites = data.filter(mod => mod.favourite === true);\n    // Switching for the active tab.\n    // foo ? foo : bar\n    const builtData = {\n        default: data,\n    };\n    return builtData;\n};\n\n/**\n * Given an object we want to prebuild a modal ready to store into a map\n *\n * @method buildModal\n * @param {Object} data The template data which contains arrays of modules\n * @return {Object} The modal for the calling section with everything already set up\n */\nconst buildModal = async(data) => {\n    const [\n        modal,\n    ] = await Promise.all([\n        ModalFactory.create({\n            type: ModalFactory.types.DEFAULT,\n            title: getString('addresourceoractivity'),\n            body: Templates.render('core_course/chooser', data),\n            large: true,\n            templateContext: {\n                classes: 'modchooser'\n            }\n        })\n    ]);\n    return modal;\n};\n\n/**\n * Now all of our setup is done we want to ensure a user can actually select a section to add a module to\n * Once a selection has been made pick out the modal & module information and pass it along\n *\n * @method registerEventHandlers\n * @param {Map} modalMap The map of modals ready to pick from when a user clicks 'Add activity'\n * @param {Map} modulesMap The map of K: sectionID V: [modules] we need to pass along so we can fetch a specific modules data\n */\nconst registerEventHandlers = (modalMap, modulesMap) => {\n    const events = [\n        'click',\n        CustomEvents.events.activate,\n        CustomEvents.events.keyboardActivate\n    ];\n\n    CustomEvents.define(document, events);\n\n    // Display module chooser event listeners.\n    events.forEach((event) => {\n        document.addEventListener(event, (e) => {\n            if (e.target.closest(selectors.elements.sectionmodchooser)) {\n                const caller = e.target.closest(selectors.elements.sectionmodchooser);\n                const sectionid = caller.dataset.sectionid;\n                const modal = modalMap.get(sectionid);\n                ChooserDialogue.displayChooser(caller, modal, modulesMap.get(sectionid));\n            }\n        });\n    });\n};\n\n/**\n * We run this last in the file as this will now allow users to select a section to add a module to\n * The assumption is that everything is set up and ready to go\n *\n * @method enableInteraction\n * @param {Array} sections The sections we need to find buttons in so we can enable the button\n */\nconst enableInteraction = (sections) => {\n    Array.from(sections).map((section) => {\n        const button = section.querySelector(`${selectors.elements.sectionmodchooser}`);\n        button.disabled = false;\n    });\n};\n"],"file":"modchooser.min.js"}